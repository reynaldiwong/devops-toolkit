@Library('your-shared-lib@main') _

def determineBranchOrTag(tag, branch) {
    if (tag) {
        return "refs/tags/${tag}"
    }
    if (branch && (branch in ['dev', 'sit'])) {
        return branch
    }
    return '*/main'
}

def buildRefspec(tag) {
    if (tag) {
        return """
            +refs/tags/${tag}:refs/remotes/origin/tags/${tag} \
            +refs/heads/*:refs/remotes/origin/*
        """.trim()
    }
    return """
        +refs/heads/*:refs/remotes/origin/* \
        +refs/tags/*:refs/tags/*
    """.trim()
}

def cfgMap
def cfg

pipeline {
    agent any

    environment {
        BRANCH = "${env.WH_PR_BRANCH ?: env.WH_RELEASE_BRANCH ?: params.ENVIRONMENT}"
        TAG = "${env.WH_RELEASE_TAG ?: params.SERVICE_TAG_OVERRIDE}"
        SERVICE_NAME = "${env.WH_PR_SERVICE_NAME ?: env.WH_RELEASE_SERVICE_NAME ?: params.SERVICE_NAME_OVERRIDE ?: 'your-service'}"
        PROJECT_NAME = "${params.PROJECT_NAME_OVERRIDE ?: 'your-project'}"
        ENVIRONMENT = "${params.ENVIRONMENT ?: 'dev'}"

        GIT_ORG = "${params.GITHUB_ORG_OVERRIDE ?: 'your-org'}"
        GIT_URL = "git@github.com:${GIT_ORG}/${SERVICE_NAME}"
        GITHUB_CREDENTIALS_ID = 'YOUR_GITHUB_SSH_KEY'
        MANIFEST_URL = 'git@github.com:your-org/manifest-template.git'

        GCP_REGION = 'your-region'
        GCP_SERVICE_ACCOUNT_KEY = 'YOUR_GCP_SERVICE_ACCOUNT_KEY'
    }

    parameters {
        string(
            name: 'GITHUB_ORG_OVERRIDE',
            defaultValue: '',
            description: 'Override github org name from webhook'
        )
        string(
            name: 'PROJECT_NAME_OVERRIDE',
            defaultValue: '',
            description: 'Override project name from webhook'
        )
        string(
            name: 'SERVICE_NAME_OVERRIDE',
            defaultValue: '',
            description: 'Override service name from webhook'
        )
        string(
            name: 'SERVICE_TAG_OVERRIDE',
            defaultValue: '',
            description: 'Override service git tag from webhook'
        )
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'sit', 'uat', 'prod'],
            description: 'Target deployment environment'
        )
    }

    options {
        buildDiscarder(
            logRotator(numToKeepStr: '10')
        )
        timeout(
            time: 1,
            unit: 'HOURS'
        )
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                [key: 'WH_PR_BRANCH', value: 'pull_request.base.ref'],
                [key: 'WH_PR_STATE', value: 'pull_request.state'],
                [key: 'WH_PR_SERVICE_NAME', value: 'pull_request.service_name'],
                [key: 'WH_RELEASE_ACTION', value: 'action'],
                [key: 'WH_RELEASE_BRANCH', value: 'release.target_commitish'],
                [key: 'WH_RELEASE_TAG', value: 'release.tag_name'],
                [key: 'WH_RELEASE_URL', value: 'release.html_url'],
                [key: 'WH_RELEASE_AUTHOR', value: 'release.author.login'],
                [key: 'WH_RELEASE_SERVICE_NAME', value: 'release.service_name']
            ],
            causeString: 'Triggered by webhook event on branch $WH_PR_BRANCH',
            token: "${env.JOB_NAME.bytes.encodeBase64().toString()}",
            regexpFilterExpression: '^closed sit$|^released (.* uat-\\d*|main prod-\\d*)$',
            regexpFilterText: '$WH_PR_STATE $WH_PR_BRANCH $WH_RELEASE_ACTION $WH_RELEASE_BRANCH $WH_RELEASE_TAG'
        )
    }

    stages {
        stage('Clean Workspace') {
            steps {
                script {
                    cleanWs()
                }
            }
        }

        stage('Checkout Service') {
            steps {
                script {
                    def checkoutConfig = [
                        $class: 'GitSCM',
                        branches: [
                            [name: determineBranchOrTag(env.TAG, env.BRANCH)]
                        ],
                        doGenerateSubmoduleConfigurations: false,
                        extensions: [
                            [$class: 'CleanBeforeCheckout'],
                            [$class: 'CleanCheckout'],
                            [$class: 'CloneOption',
                                shallow: true,
                                depth: 1,
                                noTags: false,
                                reference: '',
                                timeout: 20
                            ],
                            [$class: 'RelativeTargetDirectory', relativeTargetDir: '.'],
                            [$class: 'SubmoduleOption',
                                disableSubmodules: false,
                                parentCredentials: true,
                                recursiveSubmodules: true,
                                reference: '',
                                timeout: 20,
                                trackingSubmodules: false
                            ]
                        ],
                        submoduleCfg: [],
                        userRemoteConfigs: [
                            [
                                credentialsId: "${GITHUB_CREDENTIALS_ID}",
                                url: env.GIT_URL,
                                refspec: buildRefspec(env.TAG)
                            ]
                        ]
                    ]
                    checkout(checkoutConfig)
                }
            }
        }

        stage('Initialize') {
            steps {
                script {
                    parallel(
                        "Get Config": {
                            env.TARGET_ENV = "${env.ENVIRONMENT}"
                            cfgMap = serviceConfig(env) ?: [:]
                            cfg = cfgMap[env.SERVICE_NAME] ?: [:]
                        },
                        "Auth to GCP": {
                            withCredentials([file(credentialsId: "${GCP_SERVICE_ACCOUNT_KEY}", variable: 'GOOGLE_APPLICATION_CREDENTIALS')]) {
                                sh """
                                    gcloud auth activate-service-account --key-file=${GOOGLE_APPLICATION_CREDENTIALS}
                                    gcloud auth configure-docker asia-southeast2-docker.pkg.dev --quiet
                                """
                            }
                        },
                        "Get Manifest Template": {
                            dir('tmp/ansible') {
                                script {
                                    git branch: 'main',
                                    credentialsId: "${GITHUB_CREDENTIALS_ID}",
                                    url:  "${MANIFEST_URL}"
                                }
                            }
                        },
                        "Read Port from Dockerfile": {
                            def port = ''
                            if (fileExists('Dockerfile')) {
                                port = sh(
                                    script: 'grep -E \'^EXPOSE \' Dockerfile | awk \'{print $2}\'' ,
                                    returnStdout: true
                                ).trim()
                            } else if (fileExists('.env')) {
                                port = sh(
                                    script: '''
                                        grep -i 'PORT' .env 2>/dev/null \
                                        | head -n 1 \
                                        | awk -F'=' '{print $2}' \
                                        | tr -d '"' \
                                    ''',
                                    returnStdout: true
                                ).trim()
                            }
                            if (!port) {
                                error "No EXPOSE line found in Dockerfile or PORT variable in .env file!"
                            }
                            echo "Detected port: ${port}"
                            env.DOCKER_PORT = port
                        },
                        "Prepare Buildx Builder": {
                            echo 'activates Docker BuildKit builder'
                            sh '''
                                if ! docker buildx ls | grep -q jenkinsbuilder; then
                                    docker buildx create --use --name jenkinsbuilder
                                else
                                    docker buildx use jenkinsbuilder
                                fi
                            '''
                        }
                    )
                }
            }
        }
        
        stage('Setup Tools') {
            steps {
                script {
                    parallel(
                        "Setup Dependencies Tools": {
                            if (cfg.goTool) {
                                echo "Setting up Go tool: ${cfg.goTool}"
                                env.GO_HOME = tool name: cfg.goTool, type: 'go'
                                env.PATH = "${env.GO_HOME}/bin:${env.PATH}"
                                sh 'go version'
                            } else {
                                echo "Service ${env.SERVICE_NAME} doesn't use Go - skipping Go setup"
                            }
                            if (cfg.nodeTool) {
                                echo "Setting up Node.js tool: ${cfg.nodeTool}"
                                env.NODEJS_HOME = tool name: cfg.nodeTool, type: 'nodejs'
                                env.PATH = "${env.NODEJS_HOME}/bin:${env.PATH}"
                                sh 'node --version'
                                sh 'npm --version'
                            } else {
                                echo "Service ${env.SERVICE_NAME} doesn't use Node.js - skipping Node.js setup"
                            }
                            if (!cfg.goTool && !cfg.nodeTool) {
                                echo "Warning: No build tools configured for service ${env.SERVICE_NAME}"
                            }
                        },
                        "Set Image Name": {
                            if (ENVIRONMENT in ['dev', 'sit']) {
                                env.IMAGE_NAME = "${env.GCP_REGION}-docker.pkg.dev/${cfg.gcpProject}/${env.PROJECT_NAME}/${env.SERVICE_NAME}:latest"
                            } else if (ENVIRONMENT in ['uat', 'prod']) {
                                env.IMAGE_NAME = "${env.GCP_REGION}-docker.pkg.dev/${cfg.gcpProject}/${env.PROJECT_NAME}/${env.SERVICE_NAME}:${env.TAG}"
                            } else {
                                error "Unknown environment: ${ENVIRONMENT}. Cannot set image name."
                            }
                            echo "Set IMAGE_NAME to: ${env.IMAGE_NAME}"
                        },
                        "Get Latest Cache Image": {
                            def imagePath = "${env.GCP_REGION}-docker.pkg.dev/${cfg.gcpProject}/${env.PROJECT_NAME}/${env.SERVICE_NAME}"
                            def latestSha = sh(
                                script: """
                                    gcloud artifacts docker images list ${imagePath} \
                                    --format='get(DIGEST)' \
                                    --sort-by=~CREATE_TIME \
                                    --limit=1
                                """,
                                returnStdout: true
                            ).trim()
                            if (latestSha) {
                                env.CACHE_IMAGE = "${imagePath}@${latestSha}"
                                echo "Found latest cache image: ${env.CACHE_IMAGE}"
                            } else {
                                env.CACHE_IMAGE = ''
                                echo "No previous cache image found."
                            }
                        },
                        "Get secret and copy": {
                            GSM_LATEST = sh(script: """
                                set +x && gcloud secrets versions list ${env.SERVICE_NAME}-secret-${env.ENVIRONMENT} \
                                --project=${cfg.gcpProject} \
                                --sort-by=\"~createTime\" \
                                --limit=1 \
                                --format=\"value(NAME)\"
                            """, returnStdout: true).trim()
                            echo "Secret Version ${GSM_LATEST}"
                            sh """
                                set +x && gcloud secrets versions access latest \
                                --secret='${env.SERVICE_NAME}-secret-${env.ENVIRONMENT}' \
                                --project='${cfg.gcpProject}' \
                                > env.${env.SERVICE_NAME}
                                cp -f env.${env.SERVICE_NAME} ${WORKSPACE}/.env
                                head -2 .env
                            """
                        },
                        "Create service account": {
                            dir('tmp/ansible/automation/ansible/inventory') {
                                withCredentials([file(credentialsId: "${GCP_SERVICE_ACCOUNT_KEY}", variable: 'ansible')]) {
                                    sh "cat '$ansible' > ${WORKSPACE}/sa.json"
                                }
                            }
                        },
                        "Create ansible inventory": {
                            dir('tmp/ansible/automation/ansible/inventory') {
                                sh 'ls -lrth'
                                sh "sed 's/<GCPPROJECT>/${cfg.gcpProject}/g;s/<GCPNAMESPACE>/${env.PROJECT_NAME}/g;s/<GCPENV>/${env.BRANCH}/g;s/<APPNAME>/${env.SERVICE_NAME}/g' gcp-inventory-template.yaml > '${env.SERVICE_NAME}'.gcp.yaml"
                                sh 'ls -lrth'
                            }
                        },
                        "Create docker compose": {
                            dir('tmp/ansible/automation/docker-compose') {
                                sh 'ls -lrth'
                                sh "sed 's/<APPNAME>/${env.SERVICE_NAME}/g;s/<ENVIRONMENT>/${env.BRANCH}/g;s/<NAMESPACE>/${env.PROJECT_NAME}/g;s/<PROJECT_ID>/${cfg.gcpProject}/g;s/<PORT>/${env.DOCKER_PORT}/g' template-compose.yaml > ${env.SERVICE_NAME}-compose.yaml"
                                sh 'ls -lrth'
                            }
                        }
                    )
                }
            }
        }

        stage('SonarQube analysis') {
            environment {
                SONAR_HOST_URL = 'https://your-sonarqube-host'
                SONAR_PROJECT_KEY = "${SERVICE_NAME}"
                SONAR_BRANCH = "${BRANCH}"
                SONAR_TOKEN_ID = 'your-sonarqube-token-id'
            }
            steps {
                script {
                    def skipSonar = cfg.skipSonar ?: false
                    if (skipSonar) {
                        echo "Skipping SonarQube analysis for ${env.SERVICE_NAME}"
                        return
                    }
                    if (fileExists('go.mod')) {
                        echo 'Detected Go backend service. Running Go unit tests...'
                        sshagent(credentials: ["${GITHUB_CREDENTIALS_ID}"]) {
                            sh "go mod download && go mod tidy && CONFIG_FILE=\$(pwd)/.env go test ./... -coverprofile coverage.cov"
                        }
                    }
                    else if (fileExists('package.json')) {
                        dir('frontend') {
                            echo 'Detected frontend JS service. Running JS unit tests with coverage...'
                            sh 'npm ci'
                            sh 'npm test -- --coverage'
                        }
                    } else {
                        echo 'No recognized service type detected for unit tests.'
                    }
                    def scannerHome = tool 'SonarScanner'
                    withCredentials([string(credentialsId: "${SONAR_TOKEN_ID}", variable: 'SONAR_TOKEN')]) {
                        withSonarQubeEnv('sonarqube') {
                            def sonarGate = cfg.sonarGate ?: true
                            def sonarCmd = "${scannerHome}/bin/sonar-scanner " +
                                "-D sonar.login=${SONAR_TOKEN} " +
                                "-D sonar.projectKey=${SONAR_PROJECT_KEY} " +
                                "-D sonar.host.url=${env.SONAR_HOST_URL} " +
                                "-D sonar.branch.name=${SONAR_BRANCH} " +
                                "-D sonar.qualitygate.wait=${sonarGate} "
                            if (fileExists('go.mod')) {
                                sonarCmd += "-D sonar.go.coverage.reportPaths=coverage.cov"
                            } else if (fileExists('package.json')) {
                                sonarCmd += "-D sonar.sources=frontend/src " +
                                            "-D sonar.tests=frontend/src " +
                                            "-D sonar.javascript.lcov.reportPaths=frontend/coverage/lcov.info " +
                                            "-D sonar.language=js,ts "
                            }
                            sh sonarCmd
                        }
                    }
                    timeout(time: 5, unit: 'MINUTES') {
                        def qg = waitForQualityGate()
                        if (qg.status != 'OK') {
                            error "Pipeline aborted due to quality gate failure: ${qg.status}"
                        }
                    }
                }
            }
        }

        stage('Build') {
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: "${GITHUB_CREDENTIALS_ID}", keyFileVariable: 'SSH_KEY')]) {
                        echo "Building image: ${env.IMAGE_NAME}"
                        def cacheFromArg = env.CACHE_IMAGE ? "--cache-from=type=registry,ref=${env.CACHE_IMAGE}" : ''
                        sh """
                            docker buildx build \
                                --file Dockerfile \
                                --secret id=ssh_key,src=$SSH_KEY \
                                --tag ${env.IMAGE_NAME} \
                                ${cacheFromArg} \
                                --load \
                                .
                        """
                    }
                }
            }
        }

        stage('Push Image') {
            steps {
                script {
                    echo "Pushing Docker image: ${env.IMAGE_NAME}"
                    sh """
                        docker push ${env.IMAGE_NAME}
                    """
                }
            }
        }

        stage('Cleanup') {
            steps {
                script {
                    echo "Cleaning up local Docker resources"
                    sh """
                        docker rmi -f ${env.IMAGE_NAME} || echo 'Image not found or already removed.'
                        docker buildx prune --keep-storage 2gb
                    """
                }
            }
        }

        stage('Deploy') {
            steps {
                script {
                    echo "Deploying with Ansible..."
                    ansiblePlaybook(
                        colorized: true,
                        installation: 'ansible',
                        inventory: "tmp/ansible/automation/ansible/inventory/${env.SERVICE_NAME}.gcp.yaml",
                        playbook: 'tmp/ansible/automation/ansible/job/deployment-docker.yaml',
                        extraVars: [
                            appname: "${env.SERVICE_NAME}",
                            composerepoapp: "${WORKSPACE}/tmp/ansible/automation/docker-compose/${env.SERVICE_NAME}-compose.yaml",
                        ])
                }
            }
        }
    }
    post {
        failure {
            script {
                def webhookUrl = 'https://your-notification-host'

                def jobName = env.JOB_NAME
                def buildNumber = env.BUILD_NUMBER
                def buildUrl = env.BUILD_URL
                def status = currentBuild.currentResult

                def payload = """{
                    "job_name": "${jobName}",
                    "build_number": "${buildNumber}",
                    "build_url": "${buildUrl}",
                    "status": "${status}"
                }"""

                sh """
                curl -X POST "$webhookUrl" \
                     -H "Content-Type: application/json" \
                     -d '${payload}'
                """
            }
        }
    }
}
